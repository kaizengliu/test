<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>qingqing</title><link href="http://kaizengliu.github.io/test/" rel="alternate"></link><link href="http://kaizengliu.github.io/test/feeds/about-me.atom.xml" rel="self"></link><id>http://kaizengliu.github.io/test/</id><updated>2015-04-26T22:06:00+02:00</updated><entry><title>about me1</title><link href="http://kaizengliu.github.io/test/my-super-post.html" rel="alternate"></link><updated>2015-04-26T22:06:00+02:00</updated><author><name>liuqingqing</name></author><id>tag:kaizengliu.github.io,2015-04-26:test/my-super-post.html</id><summary type="html">&lt;h2&gt;simhash算法原理及实现&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;simhash是google用来处理海量文本去重的算法。 google出品，你懂的。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是&amp;lt;n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;simhash值的生成图解如下：
&lt;img alt="原理图" src="http://yanyiwu.com/img/simhash.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;大概花三分钟看懂这个图就差不多怎么实现这个simhash算法了。特别简单。谷歌出品嘛，简单实用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;算法过程大概如下：

1. 将Doc进行关键词抽取(其中包括分词和计算权重)，抽取出n个(关键词，权重)对， 即图中的(feature, weight)们。 记为 feature_weight_pairs = [fw1, fw2 ... fwn]，其中 fwn = (feature_n, weight_n)。

2. hash_weight_pairs = [ (hash(feature), weight) for feature, weight in feature_weight_pairs ] 生成图中的(hash,weight)们, 此时假设hash生成的位数bits_count = 6（如图）;

3. 然后对 hash_weight_pairs 进行位的纵向累加，如果该位是1，则+weight,如果是0，则-weight，最后生成bits_count个数字，如图所示是[13, 108, -22, -5, -32, 55], 这里产生的值和hash函数所用的算法相关。

4. [13,108,-22,-5,-32,55] -&amp;gt; 110001这个就很简单啦，正1负0。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到此，如何从一个doc到一个simhash值的过程已经讲明白了。 但是还有一个重要的部分没讲&lt;/p&gt;
&lt;h3&gt;simhash值的海明距离计算&lt;/h3&gt;
&lt;p&gt;二进制串A 和 二进制串B 的海明距离 就是 A xor B 后二进制中1的个数。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A = 100111;
B = 101010;
hamming_distance(A, B) = count_1(A xor B) = count_1(001101) = 3;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们算出所有doc的simhash值之后，需要计算doc A和doc B之间是否相似的条件是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A和B的海明距离是否小于等于n，这个n值根据经验一般取值为3,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simhash本质上是&lt;strong&gt;局部敏感性的哈希(（Locality-sensitive hashing，简称 LSH）)&lt;/strong&gt;，和md5之类的不一样。 正因为它的局部敏感性，所以我们可以使用海明距离来衡量simhash值的相似度&lt;/p&gt;
&lt;h3&gt;对比其他算法&lt;/h3&gt;
&lt;h4&gt;百度的去重算法&lt;/h4&gt;
&lt;p&gt;百度的去重算法最简单，就是直接找出此文章的最长的n句话，做一遍hash签名。n一般取3。 工程实现巨简单，据说准确率和召回率都能到达80%以上&lt;/p&gt;
&lt;h4&gt;shingle算法&lt;/h4&gt;
&lt;p&gt;shingle原理略复杂，不细说。 shingle算法我认为过于学院派，对于工程实现不够友好，速度太慢，基本上无法处理海量数据。&lt;/p&gt;</summary><category term="pelican"></category><category term="publishing"></category></entry></feed>